<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sonicake Command Generator & CRC Cracker</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; background-color: #2c2c2c; color: #f0f0f0; padding: 20px; font-size: 14px; line-height: 1.6; }
        .container { max-width: 900px; margin: 0 auto; }
        h1, h2 { color: #ff6b35; border-bottom: 1px solid #555; padding-bottom: 10px; }
        button { padding: 10px 15px; font-size: 16px; margin: 10px 0; border-radius: 5px; border: 1px solid #666; background-color: #444; color: white; cursor: pointer; width: 100%; transition: background-color 0.2s; }
        button:disabled { background-color: #333; opacity: 0.5; cursor: not-allowed; }
        button:hover:not(:disabled) { background-color: #555; }
        #stopBtn { background-color: #c0392b; }
        #stopBtn:hover:not(:disabled) { background-color: #e74c3c; }
        #downloadBtn { background-color: #27ae60; }
        #downloadBtn:hover:not(:disabled) { background-color: #2ecc71; }
        .log-panel, .results-panel, .controls-panel { background-color: #1e1e1e; border: 1px solid #555; border-radius: 5px; padding: 15px; margin-top: 20px; }
        #log, #results { width: 100%; height: 300px; overflow-y: scroll; font-family: 'SF Mono', 'Consolas', 'Menlo', monospace; font-size: 12px; white-space: pre; word-break: break-all; }
        .log-sent { color: #87cefa; }
        .log-received { color: #98fb98; }
        .log-error { color: #ff6b6b; }
        .log-info { color: #f0e68c; }
        .log-success { color: #32cd32; font-weight: bold; }
        .status-bar { display: flex; align-items: center; gap: 10px; background-color: #3a3a3a; padding: 10px; border-radius: 5px; margin-bottom: 20px; }
        #status-dot { width: 12px; height: 12px; border-radius: 50%; background-color: #ff6b6b; transition: background-color 0.3s; }
        #status-dot.connected { background-color: #32cd32; }
        #status-text { font-weight: bold; }
        #progress-bar-container { width: 100%; background-color: #444; border-radius: 5px; overflow: hidden; height: 20px; margin-top: 10px; }
        #progress-bar { width: 0%; height: 100%; background-color: #ff6b35; transition: width 0.1s linear; }
        #time-estimate { font-size: 12px; color: #aaa; text-align: center; margin-bottom: 8px; height: 1em; }
        .grid { display: grid; grid-template-columns: 1fr 3fr; gap: 20px; } /* Log is 1/4, Results is 3/4 */
        .test-controls { display: grid; grid-template-columns: 2fr 1fr 1fr; gap: 10px; align-items: center; }
        .param-selector { grid-column: 1 / -1; }
        .value-input-group { display: flex; align-items: center; gap: 5px; }
        .range-toggle { grid-column: 1 / -1; display: flex; align-items: center; gap: 8px; margin-top: 10px; }
        .crack-buttons { grid-column: 1 / -1; display: flex; flex-wrap: wrap; gap: 10px; }
        .test-controls select, .test-controls input, .test-controls label { background-color: #222; border: 1px solid #555; color: white; padding: 8px; border-radius: 3px; font-size: 14px; margin: 0; }
        .test-controls label { border: none; }
        .test-controls input[type="number"] { width: 80px; }
        .test-controls input[type="checkbox"] { width: auto; }
        .crack-buttons button { width: auto; font-size: 14px; padding: 8px 12px; margin: 0; flex-grow: 1; }
        @media (max-width: 768px) { .grid { grid-template-columns: 1fr; } .test-controls { grid-template-columns: 1fr; } .crack-buttons { flex-direction: column; } }
    </style>
</head>
<body>
    <div class="container">
        <h1>Command Generator & CRC Cracker</h1>
        <p>This tool automatically generates command payloads, finds the correct CRC checksum using an optimized brute-force, and outputs the complete commands.</p>

        <div class="status-bar">
            <div id="status-dot"></div>
            <span id="status-text">Disconnected</span>
        </div>

        <button id="connectBtn">1. Connect to Pedal</button>

        <div class="controls-panel">
            <h2>Targeted Cracking</h2>
            <div class="test-controls">
                <div class="param-selector">
                    <select id="paramSelect"></select>
                </div>
                <div class="value-input-group">
                    <label for="startIndexInput" id="valueLabel">Value (%):</label>
                    <input type="number" id="startIndexInput" min="0" max="100" value="0">
                </div>
                <div class="range-toggle">
                    <input type="checkbox" id="negativeRangeCheckbox">
                    <label for="negativeRangeCheckbox">Use Negative Range (-50 to 50)</label>
                </div>
                <div class="crack-buttons">
                    <button id="crackSingleBtn" disabled>Crack Single</button>
                    <button id="crack25Btn" disabled>Crack +25</button>
                    <button id="crack50Btn" disabled>Crack +50</button>
                    <button id="crack75Btn" disabled>Crack +75</button>
                    <button id="crack100Btn" disabled>Crack Full Range</button>
                </div>
            </div>
        </div>

        <button id="startBtn" disabled>Crack All (606 Commands, 0-100 Range)</button>
        <button id="stopBtn" style="display: none;">Stop Process</button>
        
        <div class="grid">
            <div class="log-panel">
                <h2>Live Log</h2>
                <div id="time-estimate"></div>
                <div id="progress-bar-container"><div id="progress-bar"></div></div>
                <div id="log"></div>
            </div>
            <div class="results-panel">
                <h2>Generated Commands</h2>
                <textarea id="results" readonly style="background-color: #222; border: 1px solid #555; color: white; padding: 10px; border-radius: 3px; resize: vertical;"></textarea>
                <button id="downloadBtn">Download Results as .js</button>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const SERVICE_UUID = '03b80e5a-ede8-4b33-a751-6ce34ec4c700';
        const CHARACTERISTIC_UUID = '7772e5db-3868-4112-a1a9-f2669d106bf3';
        const SUCCESS_ACK_CODE = "8080f00b02000100000003010400080000f7";
        const ACK_TIMEOUT = 200; 

        // --- DEVICE STATE ---
        let device = null;
        let characteristic = null;
        let currentAckResolver = null;
        let isCracking = false;

        // --- UI ELEMENTS ---
        const connectBtn = document.getElementById('connectBtn');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const crackSingleBtn = document.getElementById('crackSingleBtn');
        const crack25Btn = document.getElementById('crack25Btn');
        const crack50Btn = document.getElementById('crack50Btn');
        const crack75Btn = document.getElementById('crack75Btn');
        const crack100Btn = document.getElementById('crack100Btn');
        const paramSelect = document.getElementById('paramSelect');
        const startIndexInput = document.getElementById('startIndexInput');
        const valueLabel = document.getElementById('valueLabel');
        const negativeRangeCheckbox = document.getElementById('negativeRangeCheckbox');
        const logElement = document.getElementById('log');
        const resultsElement = document.getElementById('results');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const progressBar = document.getElementById('progress-bar');
        const timeEstimate = document.getElementById('time-estimate');

        // --- DATA MAPPING ---
        const PARAMETER_IDS = {
            'EQ lowhz': '00', 'EQ lowmidhz': '01', 'EQ midhz': '02', 'EQ treblehz': '03', 'EQ highhz': '04', 'EQ vol': '05'
        };

        const POSITIVE_VALUE_MAP = [ // 0 to 100
            '00000000', '0800030f', '00000400', '04000400', '08000400', '0a000400', '0c000400', '0e000400', '00000401',
            '01000401', '02000401', '03000401', '04000401', '05000401', '06000401', '07000401', '08000401',
            '08080401', '09000401', '09080401', '0a000401', '0a080401', '0b000401', '0b080401', '0c000401',
            '0c080401', '0d000401', '0d080401', '0e000401', '0e080401', '0f000401', '0f080401', '00000402',
            '00040402', '00080402', '000c0402', '01000402', '01040402', '01080402', '010c0402', '02000402',
            '02040402', '02080402', '020c0402', '03000402', '03040402', '03080402', '030c0402', '04000402',
            '04040402', '04080402', '040c0402', '05000402', '05040402', '05080402', '050c0402', '06000402',
            '06040402', '06080402', '060c0402', '07000402', '07040402', '07080402', '070c0402', '08000402',
            '08020402', '08040402', '08060402', '08080402', '080a0402', '080c0402', '080e0402', '09000402',
            '09020402', '09040402', '09060402', '09080402', '090a0402', '090c0402', '090e0402', '0a000402',
            '0a020402', '0a040402', '0a060402', '0a080402', '0a0a0402', '0a0c0402', '0a0e0402', '0b000402',
            'b020402', '0b040402', '0b060402', '0b080402', '0b0a0402', '0b0c0402', '0b0e0402', '0c000402',
            '0c020402', '0c040402', '0c060402', '0c080402'
        ];

        // New map for -50 to -1, in the correct order.
        const NEGATIVE_VALUE_MAP = [
            '04080C02', '04040C02', '04000C02', '030C0C02', '03080C02', '03040C02', '03000C02', '020C0C02',
            '02080C02', '02040C02', '02000C02', '010C0C02', '01080C02', '01040C02', '01000C02', '000C0C02',
            '00080C02', '00040C02', '00000C02', '0F080C01', '0F000C01', '0E080C01', '0E000C01', '0D080C01',
            '0D000C01', '0C080C01', '0C000C01', '0B080C01', '0B000C01', '0A080C01', '0A000C01', '09080C01',
            '09000C01', '08080C01', '08000C01', '07000C01', '06000C01', '05000C01', '04000C01', '03000C01',
            '02000C01', '01000C01', '00000C01', '0E000C00', '0C000C00', '0A000C00', '08000C00', '04000C00',
            '00000C00', '08000B0F'
        ];

        // Combined map for -50 to 50
        const EXTENDED_VALUE_MAP = [
            ...NEGATIVE_VALUE_MAP, // 50 values for -50 to -1
            ...POSITIVE_VALUE_MAP.slice(0, 51) // 51 values for 0 to 50
        ];

        // --- LOGIC ---
        
        const MAX_LOG_ENTRIES = 25;
        function log(message, type = 'info') {
            if (logElement.childElementCount >= MAX_LOG_ENTRIES) {
                logElement.removeChild(logElement.firstElementChild);
            }
            const timestamp = new Date().toLocaleTimeString();
            const typeClass = `log-${type}`;
            const newEntry = document.createElement('span');
            newEntry.className = typeClass;
            newEntry.textContent = `[${timestamp}] ${message}\n`;
            logElement.appendChild(newEntry);
            logElement.scrollTop = logElement.scrollHeight;
        }

        function setControlsDisabled(disabled) {
            isCracking = disabled;
            startBtn.disabled = disabled;
            crackSingleBtn.disabled = disabled;
            crack25Btn.disabled = disabled;
            crack50Btn.disabled = disabled;
            crack75Btn.disabled = disabled;
            crack100Btn.disabled = disabled;
            paramSelect.disabled = disabled;
            startIndexInput.disabled = disabled;
            negativeRangeCheckbox.disabled = disabled;
            stopBtn.style.display = disabled ? 'block' : 'none';
        }

        function populateParamSelect() {
            for (const paramName in PARAMETER_IDS) {
                const option = document.createElement('option');
                option.value = paramName;
                option.textContent = paramName;
                paramSelect.appendChild(option);
            }
        }
        populateParamSelect();

        negativeRangeCheckbox.addEventListener('change', () => {
            if (negativeRangeCheckbox.checked) {
                valueLabel.textContent = 'Value (-50 to 50):';
                startIndexInput.min = -50;
                startIndexInput.max = 50;
                startIndexInput.value = -50;
                startBtn.textContent = 'Crack All (606 Commands, -50 to 50 Range)';
            } else {
                valueLabel.textContent = 'Value (%):';
                startIndexInput.min = 0;
                startIndexInput.max = 100;
                startIndexInput.value = 0;
                startBtn.textContent = 'Crack All (606 Commands, 0-100 Range)';
            }
        });

        connectBtn.addEventListener('click', async () => {
            if (!navigator.bluetooth) {
                log('Web Bluetooth is not supported in this browser.', 'error');
                return;
            }
            try {
                log('Requesting Bluetooth device...', 'sent');
                device = await navigator.bluetooth.requestDevice({ filters: [{ services: [SERVICE_UUID] }] });
                log(`Connecting to ${device.name || 'Unknown Device'}...`, 'sent');
                device.addEventListener('gattserverdisconnected', onDisconnected);
                const server = await device.gatt.connect();
                const service = await server.getPrimaryService(SERVICE_UUID);
                characteristic = await service.getCharacteristic(CHARACTERISTIC_UUID);
                await characteristic.startNotifications();
                characteristic.addEventListener('characteristicvaluechanged', handleNotification);
                
                statusDot.classList.add('connected');
                statusText.textContent = `Connected to ${device.name}`;
                log('Device connected successfully!', 'success');
                connectBtn.disabled = true;
                setControlsDisabled(false);
            } catch (error) {
                log(`Connection failed: ${error.message}`, 'error');
            }
        });

        function onDisconnected() {
            log('Device disconnected.', 'error');
            statusDot.classList.remove('connected');
            statusText.textContent = 'Disconnected';
            connectBtn.disabled = false;
            setControlsDisabled(true);
            device = null;
            characteristic = null;
        }

        async function writeCommand(commandString) {
            if (!characteristic) return;
            try {
                const hexBytes = commandString.match(/.{1,2}/g).map(byte => parseInt(byte, 16));
                const command = new Uint8Array(hexBytes);
                await characteristic.writeValueWithoutResponse(command);
            } catch (error) {
                log(`Error sending command: ${error.message}`, 'error');
            }
        }

        function handleNotification(event) {
            const data = new Uint8Array(event.target.value.buffer);
            const hexString = Array.from(data).map(b => b.toString(16).padStart(2, '0')).join('');
            if (currentAckResolver && hexString.toLowerCase() === SUCCESS_ACK_CODE) {
                currentAckResolver(true);
            }
        }
        
        function waitForAck() {
            return new Promise((resolve) => {
                let resolved = false;
                const resolver = (success) => {
                    if (!resolved) {
                        resolved = true;
                        currentAckResolver = null;
                        clearTimeout(timeout);
                        resolve(success);
                    }
                };
                currentAckResolver = resolver;
                const timeout = setTimeout(() => resolver(false), ACK_TIMEOUT);
            });
        }

        async function findCorrectChecksum(payload) {
            for (let x = 0; x < 16; x++) {
                for (let y = 0; y < 16; y++) {
                    if (!isCracking) return null;
                    const checksum = `0${x.toString(16)}0${y.toString(16)}`;
                    const testCommand = `8080f0${checksum}${payload}f7`;
                    
                    log(`> Trying: ${testCommand}`, 'sent');
                    
                    await writeCommand(testCommand);
                    const wasSuccessful = await waitForAck();

                    if (wasSuccessful) {
                        return checksum.toUpperCase();
                    }
                }
            }
            return null;
        }

        function formatTime(ms) {
            if (ms === Infinity || isNaN(ms) || ms < 0) return '...';
            const totalSeconds = Math.round(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}m ${seconds.toString().padStart(2, '0')}s`;
        }

        async function startCrackingProcess(paramsToCrack, startIndex = 0) {
            setControlsDisabled(true);
            resultsElement.value = '';
            log('--- Starting Command Generation Process ---', 'info');

            const useNegativeRange = negativeRangeCheckbox.checked;
            const activeValueMap = useNegativeRange ? EXTENDED_VALUE_MAP : POSITIVE_VALUE_MAP;
            const valueOffset = useNegativeRange ? -50 : 0;

            let totalCommandsToCrack = 0;
            let isFirstParam = true;
            for (const paramName in paramsToCrack) {
                const loopStart = isFirstParam ? startIndex : 0;
                let count = paramsToCrack[paramName].count;
                if (count > activeValueMap.length) {
                    count = activeValueMap.length;
                }
                totalCommandsToCrack += (count - loopStart);
                isFirstParam = false;
            }

            const worstCaseTime = 256 * ACK_TIMEOUT * totalCommandsToCrack;
            timeEstimate.textContent = `Est. Time Remaining: ${formatTime(worstCaseTime)}`;

            let commandsGenerated = 0;
            let timeSamples = [];
            let avgTimePerCommand = 256 * ACK_TIMEOUT;
            isFirstParam = true;

            for (const paramName in paramsToCrack) {
                const { id: paramId } = paramsToCrack[paramName];
                let count = paramsToCrack[paramName].count;
                if (count > activeValueMap.length) {
                    count = activeValueMap.length;
                }
                
                resultsElement.value += `// --- ${paramName} ---\n`;
                
                const loopStartIndex = isFirstParam ? startIndex : 0;
                isFirstParam = false;

                for (let i = loopStartIndex; i < count; i++) {
                    if (!isCracking) {
                        log('Process stopped by user.', 'error');
                        setControlsDisabled(false);
                        timeEstimate.textContent = '';
                        return;
                    }
                    const valueBlock = activeValueMap[i];
                    const displayValue = i + valueOffset;

                    if (!valueBlock) {
                        log(`Value map missing for index ${i} (Value: ${displayValue})`, 'error');
                        continue;
                    }
                    const payload = `00010000000E01010408000500000000000000${paramId}00000000000000000000${valueBlock}`;

                    
                    log(`Cracking: ${paramName} - Value ${displayValue}...`, 'info');
                    
                    const crackStartTime = performance.now();
                    const checksum = await findCorrectChecksum(payload);
                    const crackEndTime = performance.now();

                    if (checksum) {
                        const duration = crackEndTime - crackStartTime;
                        timeSamples.push(duration);

                        const currentOverallAvg = timeSamples.reduce((a, b) => a + b, 0) / timeSamples.length;
                        if (timeSamples.length % 5 === 0 && timeSamples.length >= 5) {
                            const last5Avg = timeSamples.slice(-5).reduce((a, b) => a + b, 0) / 5;
                            avgTimePerCommand = (currentOverallAvg * 0.7) + (last5Avg * 0.3);
                        } else {
                            avgTimePerCommand = currentOverallAvg;
                        }

                        const fullCommand = `8080f0${checksum}${payload}f7`;
                        const resultLine = `'${paramName} ${displayValue}': '${fullCommand}',\n`;
                        resultsElement.value += resultLine;
                        log(`Found CRC: ${checksum} for ${paramName} ${displayValue} in ${Math.round(duration)}ms`, 'success');
                    } else {
                        const resultLine = `'${paramName} ${displayValue}': 'ERROR: CRC NOT FOUND',\n`;
                        resultsElement.value += resultLine;
                        log(`Failed to find CRC for ${paramName} ${displayValue}`, 'error');
                        if (!isCracking) break;
                    }
                    
                    commandsGenerated++;
                    const remainingCommands = totalCommandsToCrack - commandsGenerated;
                    const estimatedTimeRemaining = remainingCommands * avgTimePerCommand;
                    timeEstimate.textContent = `Est. Time Remaining: ${formatTime(estimatedTimeRemaining)}`;

                    progressBar.style.width = `${(commandsGenerated / totalCommandsToCrack) * 100}%`;
                    resultsElement.scrollTop = resultsElement.scrollHeight;
                }
            }

            log('--- Generation Complete! ---', 'success');
            timeEstimate.textContent = 'Done!';
            setControlsDisabled(false);
            startIndexInput.value = negativeRangeCheckbox.checked ? -50 : 0;
        }

        function getParams(countModifier = 0) {
            const selectedParam = paramSelect.value;
            const useNegativeRange = negativeRangeCheckbox.checked;
            const activeValueMap = useNegativeRange ? EXTENDED_VALUE_MAP : POSITIVE_VALUE_MAP;
            const valueOffset = useNegativeRange ? 50 : 0;

            const startValue = parseInt(startIndexInput.value) || (useNegativeRange ? -50 : 0);
            let startIndex = Math.max(0, startValue + valueOffset);
            
            let count = activeValueMap.length; // Default to full range
            if (countModifier === 1) { // Single
                count = startIndex + 1;
            } else if (countModifier > 1) { // +25, +50, etc.
                count = startIndex + countModifier;
            }

            // Clamp count to the max length of the value map
            if (count > activeValueMap.length) {
                count = activeValueMap.length;
            }

            const params = { [selectedParam]: { id: PARAMETER_IDS[selectedParam], count: count } };
            return { params, startIndex };
        }

        startBtn.addEventListener('click', () => {
            const useNegativeRange = negativeRangeCheckbox.checked;
            const activeValueMap = useNegativeRange ? EXTENDED_VALUE_MAP : POSITIVE_VALUE_MAP;
            const allParams = {};
            for(const paramName in PARAMETER_IDS) {
                allParams[paramName] = { id: PARAMETER_IDS[paramName], count: activeValueMap.length };
            }
            const { startIndex } = getParams(0);
            startCrackingProcess(allParams, startIndex);
        });

        crackSingleBtn.addEventListener('click', () => {
            const { params, startIndex } = getParams(1);
            startCrackingProcess(params, startIndex);
        });

        crack25Btn.addEventListener('click', () => {
            const { params, startIndex } = getParams(25);
            startCrackingProcess(params, startIndex);
        });

        crack50Btn.addEventListener('click', () => {
            const { params, startIndex } = getParams(50);
            startCrackingProcess(params, startIndex);
        });
        
        crack75Btn.addEventListener('click', () => {
            const { params, startIndex } = getParams(75);
            startCrackingProcess(params, startIndex);
});

        crack100Btn.addEventListener('click', () => { // "Crack Full Range" button
            const { params, startIndex } = getParams(0); // 0 means full range
            startCrackingProcess(params, startIndex);
        });
        
        stopBtn.addEventListener('click', () => {
            if (isCracking) {
                log('--- Stopping Process Manually ---', 'error');
                isCracking = false;
            }
        });

        downloadBtn.addEventListener('click', () => {
            const content = resultsElement.value;
            if (!content) {
                log('Results are empty, nothing to download.', 'error');
                return;
            }
            const blob = new Blob([content], { type: 'text/javascript' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'cracked_commands.js';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            log('Results file prepared for download.', 'info');
        });

    </script>
</body>
</html>
